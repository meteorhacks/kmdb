// Code generated by protoc-gen-go.
// source: protocol.proto
// DO NOT EDIT!

/*
Package kmdb is a generated protocol buffer package.

It is generated from these files:
	protocol.proto

It has these top-level messages:
	PutReq
	PutReqBatch
	PutRes
	PutResBatch
	IncReq
	IncReqBatch
	IncRes
	IncResBatch
	GetReq
	GetReqBatch
	GetRes
	GetResBatch
	ResSeries
	ResPoint
*/
package kmdb

import proto "github.com/golang/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type PutReq struct {
	Database  string   `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	Timestamp int64    `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Value     float64  `protobuf:"fixed64,3,opt,name=value" json:"value,omitempty"`
	Count     int64    `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	Fields    []string `protobuf:"bytes,5,rep,name=fields" json:"fields,omitempty"`
}

func (m *PutReq) Reset()         { *m = PutReq{} }
func (m *PutReq) String() string { return proto.CompactTextString(m) }
func (*PutReq) ProtoMessage()    {}

type PutReqBatch struct {
	Batch []*PutReq `protobuf:"bytes,1,rep,name=batch" json:"batch,omitempty"`
}

func (m *PutReqBatch) Reset()         { *m = PutReqBatch{} }
func (m *PutReqBatch) String() string { return proto.CompactTextString(m) }
func (*PutReqBatch) ProtoMessage()    {}

func (m *PutReqBatch) GetBatch() []*PutReq {
	if m != nil {
		return m.Batch
	}
	return nil
}

type PutRes struct {
}

func (m *PutRes) Reset()         { *m = PutRes{} }
func (m *PutRes) String() string { return proto.CompactTextString(m) }
func (*PutRes) ProtoMessage()    {}

type PutResBatch struct {
	Batch []*PutRes `protobuf:"bytes,1,rep,name=batch" json:"batch,omitempty"`
}

func (m *PutResBatch) Reset()         { *m = PutResBatch{} }
func (m *PutResBatch) String() string { return proto.CompactTextString(m) }
func (*PutResBatch) ProtoMessage()    {}

func (m *PutResBatch) GetBatch() []*PutRes {
	if m != nil {
		return m.Batch
	}
	return nil
}

type IncReq struct {
	Database  string   `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	Timestamp int64    `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Value     float64  `protobuf:"fixed64,3,opt,name=value" json:"value,omitempty"`
	Count     int64    `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	Fields    []string `protobuf:"bytes,5,rep,name=fields" json:"fields,omitempty"`
}

func (m *IncReq) Reset()         { *m = IncReq{} }
func (m *IncReq) String() string { return proto.CompactTextString(m) }
func (*IncReq) ProtoMessage()    {}

type IncReqBatch struct {
	Batch []*IncReq `protobuf:"bytes,1,rep,name=batch" json:"batch,omitempty"`
}

func (m *IncReqBatch) Reset()         { *m = IncReqBatch{} }
func (m *IncReqBatch) String() string { return proto.CompactTextString(m) }
func (*IncReqBatch) ProtoMessage()    {}

func (m *IncReqBatch) GetBatch() []*IncReq {
	if m != nil {
		return m.Batch
	}
	return nil
}

type IncRes struct {
}

func (m *IncRes) Reset()         { *m = IncRes{} }
func (m *IncRes) String() string { return proto.CompactTextString(m) }
func (*IncRes) ProtoMessage()    {}

type IncResBatch struct {
	Batch []*IncRes `protobuf:"bytes,1,rep,name=batch" json:"batch,omitempty"`
}

func (m *IncResBatch) Reset()         { *m = IncResBatch{} }
func (m *IncResBatch) String() string { return proto.CompactTextString(m) }
func (*IncResBatch) ProtoMessage()    {}

func (m *IncResBatch) GetBatch() []*IncRes {
	if m != nil {
		return m.Batch
	}
	return nil
}

type GetReq struct {
	Database  string   `protobuf:"bytes,1,opt,name=database" json:"database,omitempty"`
	StartTime int64    `protobuf:"varint,2,opt,name=startTime" json:"startTime,omitempty"`
	EndTime   int64    `protobuf:"varint,3,opt,name=endTime" json:"endTime,omitempty"`
	Fields    []string `protobuf:"bytes,4,rep,name=fields" json:"fields,omitempty"`
	GroupBy   []bool   `protobuf:"varint,5,rep,packed,name=groupBy" json:"groupBy,omitempty"`
}

func (m *GetReq) Reset()         { *m = GetReq{} }
func (m *GetReq) String() string { return proto.CompactTextString(m) }
func (*GetReq) ProtoMessage()    {}

type GetReqBatch struct {
	Batch []*GetReq `protobuf:"bytes,1,rep,name=batch" json:"batch,omitempty"`
}

func (m *GetReqBatch) Reset()         { *m = GetReqBatch{} }
func (m *GetReqBatch) String() string { return proto.CompactTextString(m) }
func (*GetReqBatch) ProtoMessage()    {}

func (m *GetReqBatch) GetBatch() []*GetReq {
	if m != nil {
		return m.Batch
	}
	return nil
}

type GetRes struct {
	Data []*ResSeries `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
}

func (m *GetRes) Reset()         { *m = GetRes{} }
func (m *GetRes) String() string { return proto.CompactTextString(m) }
func (*GetRes) ProtoMessage()    {}

func (m *GetRes) GetData() []*ResSeries {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetResBatch struct {
	Batch []*GetRes `protobuf:"bytes,1,rep,name=batch" json:"batch,omitempty"`
}

func (m *GetResBatch) Reset()         { *m = GetResBatch{} }
func (m *GetResBatch) String() string { return proto.CompactTextString(m) }
func (*GetResBatch) ProtoMessage()    {}

func (m *GetResBatch) GetBatch() []*GetRes {
	if m != nil {
		return m.Batch
	}
	return nil
}

type ResSeries struct {
	Fields []string    `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty"`
	Points []*ResPoint `protobuf:"bytes,2,rep,name=points" json:"points,omitempty"`
}

func (m *ResSeries) Reset()         { *m = ResSeries{} }
func (m *ResSeries) String() string { return proto.CompactTextString(m) }
func (*ResSeries) ProtoMessage()    {}

func (m *ResSeries) GetPoints() []*ResPoint {
	if m != nil {
		return m.Points
	}
	return nil
}

type ResPoint struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
	Count int64   `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
}

func (m *ResPoint) Reset()         { *m = ResPoint{} }
func (m *ResPoint) String() string { return proto.CompactTextString(m) }
func (*ResPoint) ProtoMessage()    {}

func init() {
}

// Client API for DatabaseService service

type DatabaseServiceClient interface {
	Put(ctx context.Context, in *PutReq, opts ...grpc.CallOption) (*PutRes, error)
	PutBatch(ctx context.Context, in *PutReqBatch, opts ...grpc.CallOption) (*PutResBatch, error)
	Inc(ctx context.Context, in *IncReq, opts ...grpc.CallOption) (*IncRes, error)
	IncBatch(ctx context.Context, in *IncReqBatch, opts ...grpc.CallOption) (*IncResBatch, error)
	Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetRes, error)
	GetBatch(ctx context.Context, in *GetReqBatch, opts ...grpc.CallOption) (*GetResBatch, error)
}

type databaseServiceClient struct {
	cc *grpc.ClientConn
}

func NewDatabaseServiceClient(cc *grpc.ClientConn) DatabaseServiceClient {
	return &databaseServiceClient{cc}
}

func (c *databaseServiceClient) Put(ctx context.Context, in *PutReq, opts ...grpc.CallOption) (*PutRes, error) {
	out := new(PutRes)
	err := grpc.Invoke(ctx, "/kmdb.DatabaseService/Put", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) PutBatch(ctx context.Context, in *PutReqBatch, opts ...grpc.CallOption) (*PutResBatch, error) {
	out := new(PutResBatch)
	err := grpc.Invoke(ctx, "/kmdb.DatabaseService/PutBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Inc(ctx context.Context, in *IncReq, opts ...grpc.CallOption) (*IncRes, error) {
	out := new(IncRes)
	err := grpc.Invoke(ctx, "/kmdb.DatabaseService/Inc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) IncBatch(ctx context.Context, in *IncReqBatch, opts ...grpc.CallOption) (*IncResBatch, error) {
	out := new(IncResBatch)
	err := grpc.Invoke(ctx, "/kmdb.DatabaseService/IncBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Get(ctx context.Context, in *GetReq, opts ...grpc.CallOption) (*GetRes, error) {
	out := new(GetRes)
	err := grpc.Invoke(ctx, "/kmdb.DatabaseService/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) GetBatch(ctx context.Context, in *GetReqBatch, opts ...grpc.CallOption) (*GetResBatch, error) {
	out := new(GetResBatch)
	err := grpc.Invoke(ctx, "/kmdb.DatabaseService/GetBatch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DatabaseService service

type DatabaseServiceServer interface {
	Put(context.Context, *PutReq) (*PutRes, error)
	PutBatch(context.Context, *PutReqBatch) (*PutResBatch, error)
	Inc(context.Context, *IncReq) (*IncRes, error)
	IncBatch(context.Context, *IncReqBatch) (*IncResBatch, error)
	Get(context.Context, *GetReq) (*GetRes, error)
	GetBatch(context.Context, *GetReqBatch) (*GetResBatch, error)
}

func RegisterDatabaseServiceServer(s *grpc.Server, srv DatabaseServiceServer) {
	s.RegisterService(&_DatabaseService_serviceDesc, srv)
}

func _DatabaseService_Put_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PutReq)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Put(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_PutBatch_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PutReqBatch)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).PutBatch(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Inc_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(IncReq)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Inc(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_IncBatch_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(IncReqBatch)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).IncBatch(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(GetReq)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _DatabaseService_GetBatch_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(GetReqBatch)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DatabaseServiceServer).GetBatch(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _DatabaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kmdb.DatabaseService",
	HandlerType: (*DatabaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Put",
			Handler:    _DatabaseService_Put_Handler,
		},
		{
			MethodName: "PutBatch",
			Handler:    _DatabaseService_PutBatch_Handler,
		},
		{
			MethodName: "Inc",
			Handler:    _DatabaseService_Inc_Handler,
		},
		{
			MethodName: "IncBatch",
			Handler:    _DatabaseService_IncBatch_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DatabaseService_Get_Handler,
		},
		{
			MethodName: "GetBatch",
			Handler:    _DatabaseService_GetBatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
